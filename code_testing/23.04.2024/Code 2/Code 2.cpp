#include <iostream> // Подключение стандартной библиотеки c++
using namespace std; // Указываем на использование пространства имён std, что позволяет не писать "std::" перед операторами ввода/вывода

// Определение структуры для элемента списка
struct node
{
	int elem; // Значение элемента
	node* sled; // Указатель на следующий элемент
};

// Определение класса для списка
class Spisok {
private:
	node* no, * ko; // Указатели на начало и конец списка
	int klad; // Значение удаленного элемента

public:
	void POSTROENIE(); // Функция построения списка
	void VYVOD(); // Функция вывода списка
	// Новая функция COUNT в программе 
	int COUNT(); // подсчет количества элементов в очереди
	void DOBAVLENIE(int); // Функция добавления элемента в список
	int Set_Udal() { return klad; } // Функция возвращает значение удаленного элемента
	void YDALENIE(); // Функция удаления элемента из списка
	void OCHISTKA(); // Функция очистки списка
};

// Главная функция
void main()
// В данном случае эта функция задаёт общий вид выполняемой программы
// Объединяет и использует все представленные в коде функции
{
	setlocale(LC_ALL, "Rus"); // установка русского языка
	Spisok A; // Создание объекта класса Spisok
	int el; // Переменная для хранения элемента

	A.POSTROENIE(); // Построение списка
	A.VYVOD(); // Вывод списка
	cout << "Количество элементов в очереди: " << A.COUNT() << endl; // Вывод количества элементов в очереди
	cout << "Введите добавляемый элемент: ";
	cin >> el;
	A.DOBAVLENIE(el); // Добавление элемента в список
	A.VYVOD(); // Вывод списка
	cout << "Количество элементов в очереди: " << A.COUNT() << endl; // Вывод количества элементов в очереди
	cout << "Удалим элемент из очереди.\n";
	A.YDALENIE(); // Удаление элемента из списка
	A.VYVOD(); // Вывод списка
	cout << "Количество элементов в очереди: " << A.COUNT() << endl; // Вывод количества элементов в очереди
	el = A.Set_Udal(); // Получение значения удаленного элемента
	cout << "Информационное поле удалённого звена: " << el << endl;
	A.OCHISTKA(); // Очистка списка

	cout << "\n";
	system("PAUSE"); // Указываем на остановку \ завершение программы
}

void Spisok::POSTROENIE()
// Функция создает новые узлы для каждого введенного значения и добавляет их в конец списка, формируя очередь
{
	node* r; // Указатель на новый узел
	int el; // Значение нового элемента

	cout << "Вводите элементы очереди: \n";
	cin >> el;

	// Если введенное значение не равно 0, начинаем построение списка
	if (el != 0)
	{
		r = new(node); // Создаем новый узел
		(*r).elem = el; // Присваиваем ему введенное значение
		(*r).sled = NULL; // Устанавливаем указатель на следующий элемент в NULL
		no = r; // Устанавливаем указатель на начало списка на новый узел
		ko = r; // Устанавливаем указатель на конец списка на новый узел
		cin >> el; // Считываем следующее значение

		// Пока введенное значение не равно 0, продолжаем добавлять элементы в список
		while (el != 0)
		{
			r = new(node); // Создаем новый узел
			(*r).elem = el; // Присваиваем ему введенное значение
			(*r).sled = NULL; // Устанавливаем указатель на следующий элемент в NULL
			(*ko).sled = r; // Устанавливаем указатель на следующий элемент предыдущего узла на новый узел
			ko = r; // Устанавливаем указатель на конец списка на новый узел
			cin >> el; // Считываем следующее значение
		}
	}
	else
	{
		// Если введенное значение равно 0, список пуст
		r = NULL;
		no = r;
		ko = r;
	}
}

void Spisok::VYVOD()
// Функция вывода элементов очереди
// Функция проходит по всем элементам списка, начиная с первого, и выводит их значения
// Завершает работу при достижении конца
{
	node* r; // Указатель для перемещения по списку
	cout << "Очередь: ";
	r = no; // Устанавливаем указатель на начало списка

	// Пока указатель не равен NULL (пока не достигнем конца)
	while (r != NULL)
	{
		cout << (*r).elem << " "; // Выводим значение текущего элемента
		r = (*r).sled; // Перемещаем указатель на следующий элемент
	}
	cout << endl;
}

int Spisok::COUNT() {
	node* k; // Временный указатель на узел
	int count = 0; // Счетчик элементов

	k = no; // Устанавливаем указатель на начало очереди

	// Пока указатель на узел не равен NULL, продолжаем считать элементы
	while (k != NULL)
	{
		count++; // Увеличиваем счетчик
		k = (*k).sled; // Переходим к следующему узлу
	}

	return count; // Возвращаем количество элементов в очереди
}

void Spisok::DOBAVLENIE(int el)
// Функция добавляет элемент в конец очереди
// Функция создаёт новый узел, присваивает ему введённое значение и добавляет в конец
{
	node* r; // Указатель на новый узел

	r = new(node); // Создаем новый узел
	(*r).elem = el; // Присваиваем ему введенное значение
	(*r).sled = NULL; // Устанавливаем указатель на следующий элемент в NULL

	if (no != NULL) // Если список не пуст
	{
		(*ko).sled = r; // Устанавливаем указатель на следующий элемент последнего узла на новый узел
		ko = r; // Устанавливаем указатель на конец списка на новый узел
	}
	else // Если список пуст
	{
		no = r; // Устанавливаем указатель на начало списка на новый узел
		ko = r; // Устанавливаем указатель на конец списка на новый узел
	}
}

void Spisok::YDALENIE()
// Удаляет элемент из начала очереди
// Значение удалённого элемента сохраняется в переменной klad
{
	node* q; // Указатель для удаления узла

	if (no == NULL) // Если список пуст
	{
		cout << "Удалить нельзя, так как очередь пуста!\n";
	}
	else
	{
		klad = (*no).elem; // Сохраняем значение удаляемого элемента
		q = no; // Сохраняем указатель на удаляемый узел
		no = (*no).sled; // Перемещаем указатель на начало списка на следующий узел
		delete q; // Удаляем узел
	}
}

void Spisok::OCHISTKA()
// Функция, которая очищает весь список
// Она проходит по всем элементам списка начиная с первого и удаляет их
// При удалении всех элементов указатели устанавливаются на NULL
{
	node* q; // Указатель для удаления узла

	q = no; // Устанавливаем указатель на начало списка

	// Если список не пуст
	if (no != NULL)
	{
		// Пока не достигнем конца списка
		while (no != ko)
		{
			no = (*q).sled; // Перемещаем указатель на начало списка на следующий узел
			delete q; // Удаляем узел
			q = no; // Сохраняем указатель на текущий узел
		}
		delete no; // Удаляем последний узел
		no = ko = NULL; // Устанавливаем указатели на начало и конец списка в NULL
	}
}
