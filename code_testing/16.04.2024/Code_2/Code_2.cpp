#include <iostream> // Подключение библиотеки для ввода/вывода
using namespace std; // Использование пространства имен std

struct node // Определение структуры "узел"
{
	int elem; // Элемент узла
	node* sled; // Указатель на следующий узел
};

class Spisok { // Определение класса "Список"
private:
	node* phead, * Res; // Указатели на голову списка и результат поиска
public:
	Spisok() { phead = new(node); Res = NULL; } // Конструктор класса
	~Spisok() { delete phead; } // Деструктор класса
	void POSTROENIE(); // Метод для построения списка
	void VYVOD(); // Метод для вывода списка
	node* POISK(int); // Метод для поиска элемента в списке
	void InsAfter(int); // Метод для вставки элемента после заданного
	void InsBefore(int); // Метод для вставки элемента перед заданным
	void Delete(); // Метод для удаления элемента
	void DelAfter(); // Метод для удаления элемента после заданного
	void OCHISTKA(); // Метод для очистки списка
};

void main() // Главная функция
{
	setlocale(LC_ALL, "Rus"); // Установка локали
	Spisok A; // Создание объекта класса "Список"
	int el, el1; // Объявление переменных для элементов
	node* Res_Zn; // Объявление указателя на результат

	A.POSTROENIE(); // Построение списка
	A.VYVOD(); // Вывод списка
	// Ввод элемента, после которого осуществляется вставка
	cout << "\nВведите элемент звена, после которого осуществляется вставка:\n ";
	cin >> el;
	// Ввод элемента вставляемого звена
	cout << "\nВведите элемент вставляемого звена:\n";
	cin >> el1;

	// Если элемент найден в списке
	if (A.POISK(el) != NULL)
	{
		A.InsAfter(el1); // Вставка элемента после найденного
		A.VYVOD(); // Вывод списка
	}
	else cout << "Звена с заданным элементом в кольце нет!\n"; // Если элемент не найден

	// Ввод элемента, перед которым осуществляется вставка
	cout << "\nВведите элемент звена, перед которы осуществляется вставка:\n";
	cin >> el;
	// Ввод элемента вставляемого звена
	cout << "Введите элемент вставляемого звена:\n";
	cin >> el1;

	// Если элемент найден в списке
	if (A.POISK(el) != NULL)
	{
		A.InsBefore(el1); // Вставка элемента перед найденным
		A.VYVOD(); // Вывод списка
	}
	else cout << "Звена с заданным элементом в кольце нет!\n"; // Если элемент не найден

	// Ввод элемента удаляемого звена
	cout << "\nВведите элемент удаляемого звена: ";
	cin >> el;
	// Если элемент найден в списке
	if (A.POISK(el) != NULL)
	{
		A.Delete(); // Удаление найденного элемента
		A.VYVOD(); // Вывод списка
	}
	else cout << "Звена с заданным элементом в кольце нет!"; // Если элемент не найден
	// Ввод элемента, после которого нужно удалить
	cout << "\nВведите элемент звена, после которого нужно удалить: ";
	cin >> el;
	// Если элемент найден в списке
	if (A.POISK(el) != NULL)
	{
		A.DelAfter(); // Удаление элемента после найденного
		A.VYVOD(); // Вывод списка
	}
	else cout << "Звена с заданным элементом в кольце нет!\n"; // Если элемент не найден
	A.OCHISTKA(); // Очистка списка

	cout << "\n";
	system("PAUSE"); // Пауза перед завершением программы
}

void Spisok::POSTROENIE() // Реализация метода построения списка
{
	node* t; // Объявление указателя на узел
	int el; // Объявление переменной для элемента
	t = phead; (*t).sled = NULL; // Инициализация головы списка
	cout << "Вводите элементы кольца: "; // Приглашение к вводу элементов
	cin >> el; // Ввод первого элемента
	while (el != 0) // Пока введенный элемент не равен 0
	{
		(*t).sled = new(node); // Создание нового узла
		t = (*t).sled; (*t).elem = el; // Присвоение элемента новому узлу
		cin >> el; // Ввод следующего элемента
	}
	(*t).sled = (*phead).sled; // Замыкание списка в кольцо
}

void Spisok::VYVOD() // Реализация метода вывода списка
{
	node* t; // Объявление указателя на узел
	t = (*phead).sled; // Установка указателя на начало списка
	cout << "Кольцо "; // Вывод начала сообщения
	if (t != NULL) { // Если список не пуст
		cout << (*t).elem << " "; t = (*t).sled; // Вывод первого элемента
		while (t != (*phead).sled) { // Пока не вернемся к началу списка
			cout << (*t).elem << " "; t = (*t).sled; // Вывод элемента
		}
	}
	else cout << "пусто\n"; // Если список пуст
}

node* Spisok::POISK(int el) // Реализация метода поиска элемента в списке
{
	node* t; // Объявление указателя на узел
	Res = NULL; t = (*phead).sled; // Инициализация результата и установка указателя на начало списка
	while ((*t).sled != (*phead).sled && Res == NULL) // Пока не вернемся к началу списка и не найдем элемент
		if ((*t).elem == el) Res = t; // Если элемент найден, сохраняем указатель на него
		else t = (*t).sled; // Если элемент не найден, переходим к следующему узлу

	if (Res == NULL && (*t).elem == el) // Если дошли до конца списка и элемент найден
		Res = t; // Сохраняем указатель на него
	return Res; // Возвращаем результат поиска
}

void Spisok::InsAfter(int el) // Реализация метода вставки элемента после заданного
{
	node* q; // Объявление указателя на узел
	q = new(node); // Создание нового узла
	(*q).elem = el; (*q).sled = (*Res).sled; // Присвоение элемента новому узлу и установка указателя на следующий узел
	(*Res).sled = q; // Установка указателя на новый узел в найденном узле
}

void Spisok::InsBefore(int el) // Реализация метода вставки элемента перед заданным
{
	node* q; // Объявление указателя на узел
	q = new(node); // Создание нового узла
	(*q).elem = (*Res).elem; (*q).sled = (*Res).sled; // Присвоение элемента новому узлу и установка указателя на следующий узел
	(*Res).elem = el; (*Res).sled = q; // Присвоение нового элемента найденному узлу и установка указателя на новый узел
}

void Spisok::Delete() // Реализация метода удаления элемента
{
	node* z, * q;
	if ((*Res).sled != (*phead).sled) // Если удаляемый элемент не является последним в списке
	{
		q = (*Res).sled; // Сохраняем указатель на следующий элемент
		(*Res).elem = (*((*Res).sled)).elem; // Копируем данные следующего элемента в текущий
		(*Res).sled = (*((*Res).sled)).sled; // Устанавливаем указатель на следующий элемент после следующего
		delete q; // Удаляем следующий элемент
	}
	else if ((*Res).sled == Res) // Если удаляемый элемент является единственным в списке
	{
		q = (*phead).sled; (*phead).sled = NULL; // Удаляем ссылку на элемент из головы списка
		delete q; cout << "Кольцо пусто!"; // Удаляем элемент и выводим сообщение о том, что список пуст
	}
	else // Если удаляемый элемент является последним в списке, но не единственным
	{
		z = phead; q = (*phead).sled; // Сохраняем указатели на голову списка и первый элемент
		while (q != Res) // Пока не дойдем до удаляемого элемента
		{
			z = q; // Сохраняем указатель на текущий элемент
			q = (*q).sled; // Переходим к следующему элементу
		}
		(*z).sled = (*((*z).sled)).sled; // Устанавливаем указатель на следующий элемент после удаляемого
		delete q; // Удаляем элемент
	}
}

void Spisok::DelAfter() // Реализация метода удаления элемента после заданного
{
	node* q;
	if ((*Res).sled != (*phead).sled) // Если следующий за заданным элемент не является последним в списке
	{
		q = (*Res).sled; // Сохраняем указатель на следующий элемент
		(*Res).sled = (*((*Res).sled)).sled; // Устанавливаем указатель на следующий элемент после следующего
		delete q; // Удаляем следующий элемент
	}
	else
		if ((*Res).sled == Res) // Если следующий за заданным элемент является единственным в списке
		{
			q = (*phead).sled; (*phead).sled = NULL; // Удаляем ссылку на элемент из головы списка
			delete q; cout << "Кольцо пусто!"; // Удаляем элемент и выводим сообщение о том, что список пуст
		}
		else // Если следующий за заданным элемент является последним в списке, но не единственным
		{
			q = (*phead).sled; // Сохраняем указатель на первый элемент
			(*Res).sled = (*((*Res).sled)).sled; // Устанавливаем указатель на следующий элемент после следующего
			(*phead).sled = (*Res).sled; // Устанавливаем указатель на новый первый элемент в голове списка
			delete q; // Удаляем элемент
		}
}

void Spisok::OCHISTKA() // Реализация метода очистки списка
{
	node* q, * q1;
	q = phead; // Сохраняем указатель на голову списка
	q1 = (*q).sled; // Сохраняем указатель на первый элемент
	do
	{
		q = q1; // Сохраняем указатель на текущий элемент
		q1 = (*q1).sled; // Переходим к следующему элементу
		delete q; // Удаляем текущий элемент
	} while (q1 != (*phead).sled); // Повторяем, пока не вернемся к началу списка
}