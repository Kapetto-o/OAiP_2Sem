#include <iostream> // Подключаем библиотеку для ввода и вывода данных

using namespace std; // Используем пространство имен std, что позволяет нам не писать std:: перед каждым оператором ввода/вывода

// Определение структуры узла для дерева
struct node
{
	int Key; // Ключ узла
	int Count; // Количество вхождений ключа
	node* Left; // Указатель на левого потомка
	node* Right; // Указатель на правого потомка
};

// Определение структуры для стека
struct no
{
	node* elem; // Элемент стека
	int ch; // Счетчик
	no* sled; // Указатель на следующий элемент стека
};

// Определение класса TREE
class TREE
{
private:
	node* Tree; // Указатель на корень дерева
	void PushStack(no**, node**, int*); // Метод для добавления элемента в стек
	void PopStack(no**, node**, int*); // Метод для удаления элемента из стека
	void VyvodStack(no**); // Метод для вывода стека
public:
	TREE() { Tree = new(node); (*Tree).Right = NULL; } // Конструктор класса TREE
	node* GetTreeRight() { return (*Tree).Right; } // Метод для получения правого потомка корня дерева
	void TreeSearch(int); // Метод для поиска элемента в дереве
	void VyvodTree(node*); // Метод для вывода дерева
};

void main()
{
	setlocale(LC_ALL, "Rus"); // Установка русской локали
	TREE A; // Создание объекта класса TREE
	int el; // Переменная для хранения вводимого значения
	cout << "Вводите значения информационных полей вершин: " << endl;
	cin >> el; // Ввод значения
	while (el != 0) // Пока введенное значение не равно 0
	{
		A.TreeSearch(el); // Поиск введенного значения в дереве
		cin >> el; // Ввод нового значения
	}
	A.VyvodTree(A.GetTreeRight()); // Вывод дерева
	cout << "\n";
	system("PAUSE"); // Пауза перед завершением программы
}

void TREE::TreeSearch(int el)
// Функция выполняет поиск в бинарном дереве поиска и добавляет новый узел, если введенное значение не найдено
// Если значение найдено, она увеличивает счетчик вхождений этого значения
{
	node* p1, * p2;
	int d;
	p2 = Tree;
	p1 = (*p2).Right;
	d = 1;
	while (p1 != NULL && d != 0)
	{
		p2 = p1;
		if (el < (*p1).Key)
		{
			p1 = (*p1).Left;
			d = -1;
		}
		else
			if (el > (*p1).Key)
			{
				p1 = (*p1).Right;
				d = 1;
			}
			else
				d = 0;
	}
	if (d == 0)
		(*p1).Count = (*p1).Count + 1;
	else
	{
		p1 = new(node);
		(*p1).Key = el;
		(*p1).Left = NULL;
		(*p1).Right = NULL;
		(*p1).Count = 1;
		if (d < 0)
			(*p2).Left = p1;
		else
			(*p2).Right = p1;
	}
}

void TREE::VyvodTree(node* t)
// Функция выполняет обход дерева и выводит его элементы
// В процессе обхода использует 2 стека для хранения узлов дерева
// Начинает обход с переданного ей узла, и выводит ключ каждого узла
{
	no* stk, * stk1; // Указатели на элементы стека
	node* u; // Указатель на узел дерева
	int i, n; // Переменные для хранения счетчика и индекса
	stk = stk1 = NULL; // Инициализация указателей на стек
	n = 0; // Инициализация счетчика

	// Пока указатель на узел дерева не NULL
	while (t != NULL)
	{
		PushStack(&stk1, &t, &n); // Добавление элемента в стек stk1
		// Если у узла есть правый потомок
		if ((*t).Right != NULL)
		{
			// Если у узла есть левый потомок
			if ((*t).Left != NULL)
				PushStack(&stk, &((*t).Left), &n); // Добавление левого потомка в стек stk
			t = (*t).Right; // Переход к правому потомку
		}
		else
		{
			// Если у узла есть левый потомок
			if ((*t).Left != NULL)
			{
				// Если стек stk1 не пуст
				if (stk1 != NULL)
				{
					PopStack(&stk1, &u, &n); // Удаление элемента из стека stk1
					for (i = 0; i <= n; i++)
						cout << " "; // Вывод пробелов для форматирования
					cout << (*u).Key << endl; // Вывод ключа узла
				}
				t = (*t).Left; // Переход к левому потомку
			}
			else
				// Если стек stk пуст
				if (stk == NULL)
					t = NULL;
				else
				{
					// Пока элемент стека stk не равен левому потомку элемента стека stk1
					while ((*stk).elem != (*((*stk1).elem)).Left)
					{
						PopStack(&stk1, &u, &n); // Удаление элемента из стека stk1
						for (i = 0; i <= n; i++)
							cout << " "; // Вывод пробелов для форматирования
						cout << (*u).Key << endl; // Вывод ключа узла
					}
					PopStack(&stk1, &u, &n); // Удаление элемента из стека stk1
					for (i = 0; i <= n; i++)
						cout << " "; // Вывод пробелов для форматирования
					cout << (*u).Key << endl; // Вывод ключа узла
					PopStack(&stk, &t, &n); // Удаление элемента из стека stk
				}
		}
		n = n + 1; // Увеличение счетчика
	}
	VyvodStack(&stk1); // Вывод стека stk1
}

void TREE::PushStack(no** stk, node** el, int* n)
// Функция добавляет новый элемент в стек
// Она принимает три аргумента: указатель на стек, указатель на узел дерева и указатель на счетчик
// Cоздает новый элемент стека, присваивает ему переданные значения и добавляет его в стек
// После работы функции вершина стека указывает на новый элемент
{
	no* q; // Указатель на элемент стека
	q = new(no); // Создание нового элемента стека
	(*q).elem = *el; // Присваивание элементу стека указателя на узел дерева
	(*q).ch = *n; // Присваивание элементу стека значения счетчика
	(*q).sled = *stk; // Присваивание элементу стека указателя на следующий элемент стека
	*stk = q; // Обновление указателя на вершину стека
}

void TREE::PopStack(no** stk, node** t, int* n)
// Функция удаляет элемент из стека
// Она принимает три аргумента: указатель на стек, указатель на узел дерева и указатель на счетчик
// Если стек не пуст, функция присваивает переданным указателям значения вершины стека, обновляет вершину стека и удаляет старую вершину
{
	no* q; // Указатель на элемент стека
	// Если стек не пуст
	if (*stk != NULL)
	{
		*t = (**stk).elem; // Присваивание указателю на узел дерева значения элемента стека
		*n = (**stk).ch; // Присваивание счетчику значения счетчика элемента стека
		q = *stk; // Сохранение указателя на вершину стека
		*stk = (**stk).sled; // Обновление указателя на вершину стека
		delete q; // Удаление элемента стека
	}
}

void TREE::VyvodStack(no** stk)
// Функция для вывода ключей элементов стека
// Принимает указатель на стек
// Если стек не пуст, функция присваивает указателю на узел дерева и счетчику значения вершины стека, выводит ключ узла с отступом,
// который зависит от значения счетчика, и обновляет вершину стека
{
	node* k; // Указатель на узел дерева
	int i, n; // Переменные для хранения счетчика и индекса

	// Пока стек не пуст
	while (*stk != NULL)
	{
		k = (**stk).elem; // Присваивание указателю на узел дерева значения элемента стека
		n = (**stk).ch; // Присваивание счетчику значения счетчика элемента стека
		for (i = 0; i <= n; i++)
			cout << " "; // Вывод пробелов для форматирования
		cout << (*k).Key << endl; // Вывод ключа узла
		*stk = (**stk).sled; // Обновление указателя на вершину стека
	}
}