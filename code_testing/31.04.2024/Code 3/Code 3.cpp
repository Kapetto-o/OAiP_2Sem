#include<time.h> // Подключаем библиотеку для работы со временем
#include<iostream> // Подключаем библиотеку для работы с вводом-выводом
using namespace std; // Используем пространство имен std

#define N 10 // Определяем константу N равную 10

// Определяем структуру "узел"
struct node
{
	int Key; // Ключ узла
	int Cout; // Счетчик узла
	node* Left; // Указатель на левый узел
	node* Right; // Указатель на правый узел
};

// Определяем класс "Список"
class Spisok {
private:
	node* UkStr[N]; // Массив указателей на узлы
	void Search(int, node**); // Метод поиска узла
	void PrintTree(node*, int); // Метод печати дерева
	void U_d(node**, node**); // Метод удаления узла
public:
	Spisok(); // Конструктор класса
	void BuildTree(); // Метод построения дерева
	void Sodergimoe(); // Метод вывода содержимого
	node** GetTree(unsigned i) { return &(UkStr[i]); } // Метод получения дерева
	void Udaldr(node** d, int k); // Метод удаления узла
};

// Реализация конструктора класса
Spisok::Spisok()
{
	for (int i = 0; i < N; i++)
		UkStr[i] = NULL; // Инициализируем все элементы массива указателей как NULL
}

// Реализация метода построения дерева
void Spisok::BuildTree()
{
	int klutch; // Ключ узла
	unsigned hash; // Хэш-значение

	srand(time(0)); // Инициализируем генератор случайных чисел

	cout << "\nВведите значение ключа: ";
	//cin>>klutch;
	// Для ввода чисел с клавиатуры закомментируйте следующую строку и раскомментируйте предыдущую
	klutch = rand() % 31 + 0; // Генерируем случайное число от 0 до 30
	cout << klutch;
	while (klutch != 0)
	{
		hash = klutch % 10; // Вычисляем хэш-значение
		Search(klutch, &UkStr[hash]); // Ищем узел с данным ключом
		cout << "\nВведите значение ключа: ";
		//cin>>klutch;
		klutch = rand() % 31 + 0; // Генерируем новое случайное число
		cout << klutch;
	}
}

// Реализация метода поиска узла
void Spisok::Search(int X, node** p)
{
	if (*p == NULL) // Если узел не найден
	{
		*p = new(node); // Создаем новый узел
		(**p).Key = X; // Присваиваем ключу значение X
		(**p).Cout = 1; // Инициализируем счетчик единицей
		(**p).Left = (**p).Right = NULL; // Устанавливаем указатели на левый и правый узлы как NULL
	}
	else
		if (X < (**p).Key) // Если X меньше ключа
			Search(X, &((**p).Left)); // Ищем в левом поддереве
		else
			if (X > (**p).Key) // Если X больше ключа
				Search(X, &((**p).Right)); // Ищем в правом поддереве
			else
				(**p).Cout += 1; // Если X равно ключу, увеличиваем счетчик
}

// Реализация метода вывода содержимого
void Spisok::Sodergimoe()
{
	for (int i = 0; i < N; i++)
	{
		cout << " " << i << " ";
		if (UkStr[i] == NULL) // Если дерево пусто
			cout << "Дерево пусто.\n";
		else
		{
			cout << endl;
			PrintTree(UkStr[i], 0); // Печатаем дерево
		}
		cout << "---------------------------------------------" << endl;
	}
}

// Реализация метода печати дерева
void Spisok::PrintTree(node* w, int l)
{
	if (w != NULL) // Если узел существует
	{
		PrintTree((*w).Right, l + 1); // Печатаем правое поддерево
		cout << "    ";
		for (int i = 1; i <= l; i++)
			cout << " ";
		cout << (*w).Key << endl; // Печатаем ключ узла
		PrintTree((*w).Left, l + 1); // Печатаем левое поддерево

	}
}

// Реализация метода удаления узла
void Spisok::Udaldr(node** d, int k)
{
	node** q;
	if (*d == NULL) // Если узел не найден
		cout << "Узел с заданным ключом в дереве не найден...\n";
	else
		if (k < (**d).Key) // Если k меньше ключа
			Udaldr(&((**d).Left), k); // Удаляем узел в левом поддереве
		else
			if (k > (**d).Key) // Если k больше ключа
				Udaldr(&((**d).Right), k); // Удаляем узел в правом поддереве
			else
			{
				q = d;
				if ((**q).Right == NULL) // Если правый узел отсутствует
					*d = (**q).Left; // Устанавливаем указатель на левый узел
				else
					if ((**q).Left == NULL) // Если левый узел отсутствует
						*d = (**q).Right; // Устанавливаем указатель на правый узел
					else U_d(&((**q).Left), &(*q)); // Удаляем узел
			}

}

// Реализация метода удаления узла
void Spisok::U_d(node** r, node** q)
{
	if ((**r).Right == NULL) // Если правый узел отсутствует
	{
		(**q).Key = (**r).Key; // Копируем ключ
		(**q).Cout = (**r).Cout; // Копируем счетчик
		q = r;
		*r = (**r).Left; // Устанавливаем указатель на левый узел
		delete(*q); // Удаляем узел
	}
	else
		U_d(&((**r).Right), &(*q)); // Удаляем узел в правом поддереве
}

// Главная функция
void main()
{
	setlocale(LC_ALL, "Rus"); // Устанавливаем русскую локализацию
	Spisok A; // Создаем объект класса "Список"
	int klutch; // Ключ узла
	unsigned hash; // Хэш-значение

	A.BuildTree(); // Строим дерево
	cout << "\n";
	cout << "\n";
	A.Sodergimoe(); // Выводим содержимое
	for (int i = 0; i < 4; i++)
	{
		cout << "\nВведите значение удаляемого ключа: ";
		cin >> klutch; // Вводим ключ удаляемого узла
		hash = klutch % 10; // Вычисляем хэш-значение
		A.Udaldr(A.GetTree(hash), klutch); // Удаляем узел
		cout << "        Содержимое хэш-списка: \n";
		cout << "  ----------------------------\n";
		A.Sodergimoe(); // Выводим содержимое
	}
	cout << "\n";
	system("PAUSE"); // Остановка работы программы
}